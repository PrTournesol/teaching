//---------------------------------
// Cours sur Git
// (c) JMB - 2014
//---------------------------------
[[git]]
= Gestion de version avec *git*
J.-M. Bruel <jbruel@gmail.com>
v2.0 {localdate}
:imagesdir: images
//------------------------------------ variables de configuration
// only used when master document
ifndef::jmbtopic[]
:linkcss:
:git-version: 2.9.2
:icons: font
:experimental:
:toc-title: Table des matières
:toc: left
:numbered:
:status:
:siteurl: http://jmbhome.github.io/teaching/git.html
//------------------------------------ Slides uniquement
ifdef::slides[]
//--------------------- dzslides slides
ifdef::dzslides[]
:dzslides-style: tomorrow
//:dzslides-style: stormy, watermelon, tomorrow, truffle, statement, default
:dzslides-transition: fade
:dzslides-fonts: family=Yanone+Kaffeesatz:400,700,200,300&family=Cedarville+Cursive
//:dzslides-highlight: asciidoctor
:dzslides-highlight: monokai
:source-highlighter: highlightjs
:dzslides-status:
:topic: .topic
:intro: .topic.intro
:statement: .topic.statement
:incremental: .incremental
:source: .topic.source
endif::dzslides[]
//----------- deck.js --------------
ifdef::deckjs-slides[]
:viewport: width=1024, user-scalable=no
//:backend: deckjs # Should be used in the asciidoctor command (asciidoctor -b deckjs)
// swiss, neon, beamer, web-2.0
:deckjs_theme: swiss
//fade, horizontal-slide, vertical-slide
//:deckjs_transition: fade
:goto:
:menu:
//:navigation:
:status:
:sectids!:
endif::deckjs-slides[]
endif::slides[]
//------------------------------------ HTML uniquement
ifndef::slides[]
:topic:
:intro:
:statement:
:incremental: %step
:source:
endif::slides[]
endif::jmbtopic[]

// ------------------------------------------ definitions
ifndef::definitions[]
include::../definitions.txt[]
endif::definitions[]

ifdef::slides[]
// ------------------------------------------ disclaimer
:numbered!:
[{intro}]
== Avant-propos

[{topic}]
== Pour suivre en live... icon:mobile[] icon:tablet[] icon:laptop[]

[{statement}]
{siteurl}

/////
//image::qrcode.png[role="middle stretch-y"]
[qrcode, target='presentation-qrcode.png', size=20, alt='{slidesurl}', role='middle stretch-y']
----
{siteurl}
----

[geb]
....
go "http://google.com"
$("input", name: "q").value("asciidoctor")
Tread.sleep(5000)
....

.Google Landing page
screenshot::http://google.com[google]
/////

endif::slides[]

// ------
[{topic}]
== Environnement

ifdef::slides[]
- {git} [detail]#(v.`{git-version}`)#
- {giturl}
endif::slides[]
ifndef::slides[]
Vous pouvez installer {git} depuis le site officiel.
Nous utilisons ici la version `{git-version}` en ligne de commande.
Mais vous pouvez bien sûr utiliser un client graphique (comme https://www.sourcetreeapp.com/).

endif::slides[]

ifndef::slides[.Client graphique (https://www.sourcetreeapp.com/)]
image::sourcetree.png[link="https://www.sourcetreeapp.com/",width=49%]

ifndef::slides[.Lignes de commande]
image::git-term.png[width=49%]

ifndef::slides[]
[NOTE]
====
Je vous reommande tout de même de connaître les commandes en ligne, c'est souvent utile!
Pour vous familiariser avec les commandes {git} en ligne, ne pas hésiter à utiliser le site http://try.github.com/levels/1/challenges/1[http://try.github.com].
====
endif::slides[]

// ------
[{topic}]
== Principes généraux

ifndef::slides[.Usage classique de git (http://nvie.com/posts/a-successful-git-branching-model/)]
image::git-branching.png[width="70%",link="http://nvie.com/posts/a-successful-git-branching-model/",window="_blank"]

ifndef::slides[]
[NOTE]
====
Ce modèle est controversé et ne fait pas l'hunanimité.
Nous verrons dans la suite qu'il y a plus simple.
====
endif::slides[]

// ------
[{topic}]
== Avant de commencer

On initialise certaine variables (une fois pour toute en général) :

[source]
----------------------------------------------------------------------
$ git config --global user.name "JM Bruel"
$ git config --global user.email jbruel@gmail.com
$ git config --global alias.co checkout
----------------------------------------------------------------------

// ------
ifdef::slides[== !]

[TIP]
====
Ces informations sont stockées dans le fichier `~/.gitcongif`.

Voici un extrait du mien :

[source]
----------------------------------------------------------------------
[user]
        name = Jean-Michel Bruel
        email = jbruel@gmail.com
[alias]
        co = checkout
        st = status
----------------------------------------------------------------------

Ce qui donne :
[source]
----------------------------------------------------------------------
$ git co
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
$ git checkout
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
----------------------------------------------------------------------
====


// ------
[{intro}]
== Scénario *classique* (et idéal)

ifndef::slides[:leveloffset: +1]

// ------
[{topic}]
== Etape 1 : création du _repository_ local

On démarre la gestion de version :

[source]
----------------------------------------------------------------------
$ git init
----------------------------------------------------------------------


[TIP]
====
Génération d'un répertoire `.git` dans le répertoire courant.

[source]
----------------------------------------------------------------------
$ git init
Initialized empty Git repository in /tmp/.git/

$ ll
total 0
drwxr-xr-x   3 bruel  admin   102 21 jul 17:29 ./
drwxr-xr-x  35 bruel  admin  1190 21 jul 17:29 ../
drwxr-xr-x  10 bruel  admin   340 21 jul 17:29 .git/
----------------------------------------------------------------------

====

// ------
[{topic}]
== Etape 2 : ajout des fichiers

On ajoute les fichiers courants au dépôt :

[source]
----------------------------------------------------------------------
$ git add .
----------------------------------------------------------------------

[NOTE]
====
[{incremental}]
- Ne pas forcément tout ajouter (`git add *.c` par exemple pour ne versionner que les sources).
====

[TIP]
====
[{incremental}]
- Pensez à créer un fichier `.gitignore` pour éviter d'ajouter les fichiers indésirables (comme les fichiers de `log`).
====

// ------
[{topic}]
== Etape 2 (suite) : vérification

On peut visualiser les actions en vérifiant l'*état courant* du dépôt :

[source]
----------------------------------------------------------------------
$ git status
# On branch master
# Your branch is ahead of 'origin/master' by 1 commit.
#
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   Generalites.txt
#	deleted:    S3/128056_56.d
...
----------------------------------------------------------------------

// ------
[{topic}]
== Etape 3 : Commit

Pour entériner les changements :

[source]
----------------------------------------------------------------------
$ git commit -m "First draft"
[master (root-commit) 4f40f5d] First draft
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 titi.txt
 create mode 100644 toto.txt
----------------------------------------------------------------------

[NOTE]
====
[{incremental}]
- Retenez que le `commit` est uniquement local!
- Mais même en local, il est bien utile en cas de problème.
====

// ------
[{topic}]
== Etape 3 (suite) : Gestion "locale"

Exemple de scénario type (suppression exceptionnelle et rattrapage) :

[source]
----------------------------------------------------------------------
$ rm titi.txt
$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	deleted:    titi.txt
#
no changes added to commit (use "git add" and/or "git commit -a")

$ git checkout -f
$ ls titi.txt
titi.txt
----------------------------------------------------------------------

// ------
[{topic}]
== Etape 4 : Trouver un hébergement distant

Il existe de nombreux endroits disponibles pour héberger du code libre.
Les plus connus sont {gitHub} et {gitlab}.

image::github.png[width="70%"]

// ------
[{topic}]
== Etape 4 (suite) : déclarer le dépôt distant

Après avoir créé un dépôt distant, il n'y a plus qu'à associer ce
dépôt distant avec le notre.

[source]
----------------------------------------------------------------------
$ git remote add origin git@github.com:jmbruel/first_app.git <1>
$ git push -u origin master <2>
Counting objects: 3, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 225 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:jmbruel/first_app.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.
----------------------------------------------------------------------
<1> Il est possible d'avoir plusieurs dépôts distants, celui-ci sera référencé par `origin`.
<2> L'option `-u origin master` permet d'associer une fois pour toute les `git push` suivants au fait
de "pousser" sur la branche `master` du dépôt `origin` (comme l'indique la dernière ligne).
//''

// ------
[{topic}]
== Etape 5 : branch, edit, commit, merge

En cas d'édition et de commit local :

[source]
----------------------------------------------------------------------
$ git checkout
Your branch is ahead of 'origin/master' by 1 commit.
----------------------------------------------------------------------

// ------
[{topic}]
== Etape 5 (suite) : branching

{git} est très bon pour créer des branches :

[source]
----------------------------------------------------------------------
$ git checkout -b testModifTiti
Switched to a new branch 'testModifTiti'
$ git branch
  master
* testModifTiti <1>
----------------------------------------------------------------------
<1> La branche courante est repérée par un `*`.

// ------
[{topic}]
== Etape 5 (suite) : edit

Après modification :

[source]
----------------------------------------------------------------------
$ git status
# On branch testModifTiti
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   titi.txt
#
no changes added to commit (use "git add" and/or "git commit -a")
----------------------------------------------------------------------

// ------
[{topic}]
== Etape 5 (suite) : commit

On "sauvegarde" les changements :

[source]
----------------------------------------------------------------------
$ git commit -am "modif de titi"
[testModifTiti 4515b5d] modif de titi
 1 files changed, 7 insertions(+), 0 deletions(-)
----------------------------------------------------------------------

[WARNING]
====
[{incremental}]
- On ne "sauvegarde" qu'en local!
====

// ------
[{topic}]
== Etape 5 (suite) : utilisation des branches

On peut "zapper" d'une branche à l'autre à volonté :

[source]
----------------------------------------------------------------------
$ ll titi*
-rw-rw-r--    1 bruel  staff   331 12 nov 12:39 titi.txt

$ git co master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.

$ ll titi*
-rw-rw-r--    1 bruel  staff     0 12 nov 12:40 titi.txt
----------------------------------------------------------------------

// ------
[{topic}]
== Etape 5 (suite) : merge

Maintenant que la branche a été développée (testée, etc.) on peut
l'intégrer à la branche principale :

[source]
----------------------------------------------------------------------
$ git co master
Switched to branch 'master'

$ git merge testModifTiti
Merge made by recursive.
 titi.txt |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)
----------------------------------------------------------------------

[NOTE]
====
[{incremental}]
- On peut ensuite détruire la branche devenue inutile `git branch -d testModifTiti`.
- C'est une bonne habitude à prendre.
- Notez que l'historique des modifications (ainsi que les messages de commits successifs ne sont pas perdus).
====

// ------
[{topic}]
== Etape 6 : push

Maintenant que notre dépôt est satisfaisant, on peut le synchroniser avec le dépôt distant :

[source]
----------------------------------------------------------------------
$ git push
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 977 bytes, done.
Total 9 (delta 2), reused 0 (delta 0)
To git@github.com:jmbruel/first_app.git
   6103463..3aae48a  master -> master
----------------------------------------------------------------------

// ------
[{topic}]
== Dépôts existants

Si vous devez partir d'un dépôt existant :

[source]
----------------------------------------------------------------------
$ git clone git@github.com:jmbruel/first_app.git
----------------------------------------------------------------------

[TIP]
====
[{incremental}]
- Pour obtenir le nom du dépôt distant : `git remote -v`.
- Vous avez aussi le nom du dépôt distant dans le fichier `.git/config`.
====

// ------
[{topic}]
== Illustration des branches

Voici une illustration de l'utilisation des branches (tirée de http://git-scm.com/book[git-scm]).

On part d'une situation type :

ifndef::slides[.Situation initiale]
image::gf1.svg[width="50%"]

// ------
[{topic}]
== Illustration des branches (suite)

On crée une branche (appelée `iss53` ici pour indiquer qu'elle traite de l'_issue_ numéro 53) :

[source]
----------------------------------------------------------------------
$ git checkout -b iss53
----------------------------------------------------------------------

ifndef::slides[.Création d'une branche]
image::gf2.svg[width="50%"]

[NOTE]
====
[{incremental}]
- Notez que git n'a rien créé d'autre qu'un pointeur de plus => aucun espace mémoire perdu.
====

// ------
[{topic}]
== Illustration des branches (suite)

On modifie et on commit :

[source]
----------------------------------------------------------------------
$ edit ...
$ git commit -m " blabla iss53"
----------------------------------------------------------------------

ifndef::slides[.On commence à diverger de `master`]
image::gf3.svg[width="50%"]

// ------
[{topic}]
== Illustration des branches (suite)

On revient à la branche maître pour tester une autre solution :

[source]
----------------------------------------------------------------------
$ git checkout master
$ git checkout -b hotfix
$ edit ...
$ git commit -m " blabla hotfix"
----------------------------------------------------------------------

ifndef::slides[.Maintenant on a 2 branches parallèles (en plus de `master`)]
image::gf4.svg[width="50%"]

// ------
[{topic}]
== Illustration des branches (suite)

On intègre cette solution à la branche principale :

[source]
----------------------------------------------------------------------
$ git checkout master
$ git merge hotfix
----------------------------------------------------------------------

ifndef::slides[.Merge de deux branches (en _fast-forward_)]
image::gf5.svg[width="40%"]

[NOTE]
====
[{incremental}]
- {git} utilise ici le *fast-forward*
====

// ------
[{topic}]
== Illustration des branches (suite)

On continue à travailler sur la branche `iss53` :

[source]
----------------------------------------------------------------------
$ git branch -d hotfix <1>
$ git checkout iss53
$ edit ...
$ git commit -m " blabla iss53"
----------------------------------------------------------------------
<1> Destruction de la branche devenue redondante avec `master`.

ifndef::slides[.On retravaille sur `iss53`]
image::gf6.svg[width="50%"]

// ------
[{topic}]
== Illustration des branches (suite)

On intègre cette branche :

[source]
----------------------------------------------------------------------
$ git checkout master
$ git merge iss53
----------------------------------------------------------------------

ifndef::slides[.Explications du fonctionnement du merge sans _fast-forward_]
image::gf7.svg[width="50%"]

[NOTE]
====
[{incremental}]
- Explications : {git} recherche la racine commune (ici `c3` pour intégrer
les branches (les commits feuilles) une par une et vérifier les conflits par itérations à partir de cette racine.
====

// ------
[{topic}]
== Illustration des branches (suite)

ifndef::slides[.Situation finale]
image::gf8.svg[width="50%"]

[NOTE]
====
[{incremental}]
- On part du principe qu'il n'y a pas eu de <<conflits>>.
- On peut maintenant supprimer `iss53`.
====

// ------
[{topic}]
== Bonne utilisation

Revenons sur l'exemple type :

ifndef::slides[.Usage classique de git (http://nvie.com/posts/a-successful-git-branching-model/)]
image::git-branching.png[width="70%",link="http://nvie.com/posts/a-successful-git-branching-model/",window="_blank"]

ifndef::slides[:leveloffset: -1]

// ------
[{intro}]
== Gestion des branches

ifdef::slides[== !]

La principale difficulté de {git} vient de la liberté en termes de branches.

[[conflits]]
// ------
[{intro}]
== Gestion des conflits

ifdef::slides[== !]

La principale activité du programmeur qui utilise {git} en équipe vient de la gestion des conflits.

// ------
[{intro}]
== Git avancé : Git-Flow

ifdef::slides[== !]

http://danielkummer.github.io/git-flow-cheatsheet/

// ------
[{intro}]
== Wrap-up

// ------
[{topic}]
== Résumé des commandes

Voici un schéma pour résumer la philosophie (tiré de http://osteele.com) :

ifndef::slides[.Résumé des commandes {git} (http://osteele.com)]
image::git-resume.png[width="50%",link="http://osteele.com"]

// ------
[{topic}]
== Liens utiles

Le site de référence::
  http://git-scm.com/
GitHub::
  https://github.com/
Un excellent livre en ligne sur {Git}::
  http://git-scm.com/book
Comparaison entre merge/rebase/etc.::
  https://developer.atlassian.com/blog/2014/12/pull-request-merge-strategies-the-great-debate/?utm_source=twitter&utm_medium=social&utm_campaign=atlassian_pull-request-merge-strategies-the-great-debate[ici]
// ------
[{topic}]
== Glossaire

_fast_forward_::
Quand on merge une branche depuis un noeud situé  sur le même "historique".
Il s'agit donc pour {git} d'un simple déplacement de pointeur!
